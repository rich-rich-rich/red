<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <title>红色记忆 - 沉浸版</title>  
    <style>  
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Microsoft YaHei', serif; }  
        canvas { display: block; }  
        #ui-layer {  
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);  
            width: 90%; max-width: 800px; color: #fff; text-align: center;  
            pointer-events: none; opacity: 0; z-index: 100; transition: opacity 0.5s;
        }  
        .card-inner-box {  
            background: radial-gradient(circle at center, rgba(120, 0, 0, 0.9) 0%, rgba(20, 0, 0, 0.95) 100%);  
            padding: 40px; border-radius: 30px; border: 2px solid rgba(255, 215, 0, 0.5);  
            box-shadow: 0 0 100px rgba(0,0,0,0.9); backdrop-filter: blur(20px);  
        }  
        .card-title { font-size: 3em; color: #f3e5ab; margin-bottom: 15px; letter-spacing: 10px; font-weight: bold; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }  
        .card-sub { font-size: 1.4em; color: #ffcc00; margin-bottom: 20px; }
        .card-desc { font-size: 1.2em; line-height: 1.8; color: #eee; border-top: 1px solid rgba(255,215,0,0.3); padding-top: 20px; }  
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #ffcc00; }  
        #debug-info { position: fixed; bottom: 10px; left: 10px; color: rgba(255,255,255,0.6); font-size: 14px; z-index: 1001; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; }
    </style>  
</head>  
<body>  

<div id="loading-screen">  
    <div style="letter-spacing: 4px; font-size: 1.5em;">红色记忆：引擎启动中...</div>  
</div>  

<div id="debug-info">正在请求高清摄像头权限...</div>

<div id="ui-layer">  
    <div class="card-inner-box">  
        <div id="title" class="card-title"></div>  
        <div id="sub" class="card-sub"></div>
        <div id="desc" class="card-desc"></div>  
    </div> 
</div>  

<video id="video-input" style="display:none;" playsinline></video>  

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>  
let scene, camera, renderer, cardGroup, cards = [];
let lightPoint, particleSystem, particleGeometry, starField, handSpotLight;
let raycaster = new THREE.Raycaster();
let isGrabbing = false, selectedCard = null, isAnimating = false;
let grabCounter = 0;
let rotationSpeed = 0.003, targetSpeed = 0.003;

const rawData = [
    { name: "湘江战役", sub: "雄关漫道真如铁，而今迈步从头越", desc: "湘江血雨虽寒，然星火不灭。后辈若逢困厄，当反思前路，校准方向。即使跌落谷底，只要信念尚存，便能重新出发。" },
    { name: "遵义会议", sub: "“东方欲晓，莫道君行早”", desc: "遵义城头，风雨虽急，然灯塔已明。这是长征路上的“东方欲晓”，为红军指明了正确航向，让迷茫化为笃定。" },
    { name: "四渡赤水", sub: "“你打你的，我打我的”", desc: "敌军围追堵截，我们忽东忽西，不按常理出牌。在困局中坚持自己的节奏，以变应变，方能走出活路。" },
    { name: "巧渡金沙江", sub: "“兵无常势，水无常形”", desc: "水流湍急，不选硬碰，而选智取。遇到死胡同别死脑筋，换个角度思考，天地自宽。" },
    { name: "强渡大渡河", sub: "“为有牺牲多壮志，敢教日月换新天”", desc: "勇士用生命铺就过河路。这份劲头如今应化作对生活的赤诚，把手头的事做到极致。" },
    { name: "飞夺泸定桥", sub: "“狭路相逢勇者胜”", desc: "铁索寒，水流急。夺桥靠的是明知艰险也绝不退缩的那一跨。面对困难，气势不能输。" },
    { name: "翻雪山", sub: "“世上无难事，只要肯攀登”", desc: "高寒缺氧，同胞相扶。个人的力量有限，但团队的温暖能熔断冰雪，翻过最难的高山。" },
    { name: "过草地", sub: "“行到水穷处，坐看云起时”", desc: "粮草断绝，泥潭深陷。在最绝望的时候也要看一眼云端，心中有希望，脚下就有路。" },
    { name: "吴起镇会师", sub: "“数风流人物，还看今朝”", desc: "革命火种在此扎根。当年前辈眼里的“今朝”，就是你们现在正在奔赴的好日子。" },
    { name: "会宁会师", sub: "“云程发轫，万里可期”", desc: "三军汇聚，红旗招展。这种大团圆的期盼，就是国家复兴、万家灯火的开端。" },
    { name: "1949年中华人民共和国成立", sub: "人间正道是沧桑", desc: "天安门城楼的宣告，是无数血汗换来的正道。珍惜当下，沿着这条路走下去，比什么都强。" },
    { name: "十一届三中全会", sub: "“沉舟侧畔千帆过，病树前头万木春”", desc: "这是一场伟大的转折。敢于承认错误，敢于开辟新路，春天自然会破土而出。" },
    { name: "深圳特区设立", sub: "“领异标新二月花”", desc: "在荒滩上画圈，靠的是闯劲。敢为人先，才能在时代的浪潮里占得先机。" },
    { name: "香港回归", sub: "“运筹帷幄之中，决胜千里之外”", desc: "紫荆花开，百年梦圆。这是国家实力与外交智慧的结晶，稳扎稳打，终得圆满。" },
    { name: "澳门回归", sub: "自信人生二百年，会当水击三千里", desc: "莲花盛放，信心倍增。这份自信源于血脉的相连，源于对民族未来的无限憧憬。" },
    { name: "加入世贸", sub: "“敢为天下先”", desc: "敲开世界大门，直面竞争。不惧风浪，在合作中求强，这是中国智慧的全球表达。" },
    { name: "青藏铁路", sub: "“众人拾柴火焰高”", desc: "天路入云端，那是无数人的脊梁顶起的奇迹。团结协作，是攻克一切天险的法宝。" },
    { name: "奥运盛会", sub: "“人心齐，泰山移”", desc: "北京夏奥与冬奥，向世界展示了中国力量。这种凝聚力，是我们在任何赛场制胜的关键。" },
    { name: "建党百年", sub: "星火已燎原，百年基业固", desc: "从小船到巨轮，这一百年的路走得波澜壮阔。只要根基牢固，未来必将更加灿烂。" },
    { name: "长征胜利90周年", sub: "长征九秩开新境", desc: "九十年，精神不老。长征没有终点，每一代人都要走好属于自己的长征路。" }
];

function loadTex(name) {
    const loader = new THREE.TextureLoader();
    const tex = loader.load('./' + encodeURIComponent(name) + '.jpg');
    tex.colorSpace = THREE.SRGBColorSpace; 
    return tex;
}

async function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 0); 

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputColorSpace = THREE.SRGBColorSpace; 
    document.body.appendChild(renderer.domElement);

    createGalaxy();
    createParticleSystem();
    createTarotRing();

    // 1. 创建始终可见的小黄点
    lightPoint = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 32, 32), 
        new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.9, depthTest: false }) 
    );
    lightPoint.renderOrder = 999; // 确保在最上层
    scene.add(lightPoint);

    // 2. 环境光和随手点光源
    scene.add(new THREE.AmbientLight(0xffffff, 1.2)); 
    handSpotLight = new THREE.PointLight(0xffcc00, 200, 100);
    scene.add(handSpotLight);

    await initHandTracking();
    
    gsap.to('#loading-screen', { opacity: 0, duration: 1.5, onComplete: () => {
        document.getElementById('loading-screen').style.display = 'none';
    }});
    animate();
}

function createTarotRing() {
    cardGroup = new THREE.Group();
    scene.add(cardGroup);
    const radius = 28; 
    const cardGeo = new THREE.BoxGeometry(5, 7.5, 0.15);
    const backTex = loadTex('back');

    rawData.forEach((data, i) => {
        const angle = (i / rawData.length) * Math.PI * 2;
        const mats = [
            new THREE.MeshStandardMaterial({ color: 0x330000 }), 
            new THREE.MeshStandardMaterial({ color: 0x330000 }),
            new THREE.MeshStandardMaterial({ color: 0x330000 }),
            new THREE.MeshStandardMaterial({ color: 0x330000 }),
            new THREE.MeshStandardMaterial({ map: loadTex(data.name), roughness: 0.3 }), 
            new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.5 })           
        ];
        const card = new THREE.Mesh(cardGeo, mats);
        card.position.set(Math.sin(angle) * radius, 0, Math.cos(angle) * radius);
        card.lookAt(0, 0, 0); 
        card.rotateY(Math.PI); 
        card.userData = { angle: angle, info: data };
        cards.push(card);
        cardGroup.add(card);
    });
}

async function initHandTracking() {
    const debug = document.getElementById('debug-info');
    // 使用更兼容的模型路径
    const hands = new Hands({ 
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424515/${file}` 
    });
    
    hands.setOptions({ 
        maxNumHands: 1, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.6, 
        minTrackingConfidence: 0.6 
    });

    hands.onResults(res => {
        if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            debug.innerText = "手势引擎：已连接 (捏合手指抓取卡牌)";
            const p = res.multiHandLandmarks[0];
            
            // 镜像坐标处理
            const x = (0.5 - p[8].x) * 45; 
            const y = (0.5 - p[8].y) * 35;
            targetSpeed = (0.5 - p[8].x) * 0.1;

            const targetPos = new THREE.Vector3(x, y, -25);
            lightPoint.position.lerp(targetPos, 0.2);
            handSpotLight.position.copy(lightPoint.position);

            // 捏合判断 (食指指尖 p[8] 和 大拇指指尖 p[4])
            const d = Math.hypot(p[4].x - p[8].x, p[4].y - p[8].y);
            if (d < 0.04) {
                grabCounter++;
                if (grabCounter > 3 && !isGrabbing) { tryGrab(); isGrabbing = true; }
            } else if (d > 0.08) {
                grabCounter = 0;
                if (isGrabbing) { tryRelease(); isGrabbing = false; }
            }
        } else {
            debug.innerText = "手势引擎：正在寻找手部...";
        }
    });

    const video = document.getElementById('video-input');
    const cam = new Camera(video, { 
        onFrame: async () => { await hands.send({ image: video }); }, 
        width: 640, height: 480 
    });
    cam.start().catch(err => {
        debug.innerText = "错误：摄像头启动失败，请检查HTTPS环境";
    });
}

// 保持 tryGrab, tryRelease, createGalaxy, createParticleSystem 逻辑一致...
function tryGrab() {
    if (selectedCard || isAnimating) return;
    const dir = lightPoint.position.clone().normalize();
    raycaster.set(new THREE.Vector3(0,0,0), dir);
    const intersects = raycaster.intersectObjects(cards);

    if (intersects.length > 0) {
        isAnimating = true;
        selectedCard = intersects[0].object;
        scene.attach(selectedCard);
        document.getElementById('title').innerText = selectedCard.userData.info.name;
        document.getElementById('sub').innerText = selectedCard.userData.info.sub;
        document.getElementById('desc').innerText = selectedCard.userData.info.desc;
        const tl = gsap.timeline({ onComplete: () => { isAnimating = false; } });
        tl.to(selectedCard.position, { x: 0, y: 0.5, z: -12, duration: 1, ease: "expo.out" }, 0)
          .to(selectedCard.rotation, { x: 0, y: 0, z: 0, duration: 1, ease: "expo.out" }, 0)
          .to('#ui-layer', { opacity: 1, duration: 0.5 }, 0.5);
    }
}

function tryRelease() {
    if (!selectedCard || isAnimating) return;
    isAnimating = true;
    gsap.to('#ui-layer', { opacity: 0, duration: 0.3 });
    const tempCard = selectedCard;
    const originAngle = tempCard.userData.angle;
    selectedCard = null;
    gsap.to(tempCard.scale, { x: 0, y: 0, z: 0, duration: 0.5, onComplete: () => {
        cardGroup.attach(tempCard);
        tempCard.position.set(Math.sin(originAngle)*28, 0, Math.cos(originAngle)*28);
        tempCard.lookAt(0,0,0);
        tempCard.rotateY(Math.PI);
        gsap.to(tempCard.scale, { x:1, y:1, z:1, duration: 0.8 });
        isAnimating = false;
    }});
}

function createGalaxy() {
    const geo = new THREE.BufferGeometry();
    const pts = [], cols = [];
    for(let i=0; i<15000; i++) {
        const r = 300 + Math.random() * 500;
        const t = Math.random() * Math.PI * 2, p = Math.random() * Math.PI;
        pts.push(r * Math.sin(p) * Math.cos(t), r * Math.sin(p) * Math.sin(t), r * Math.cos(p));
        const color = new THREE.Color().setHSL(Math.random() * 0.1, 0.8, 0.5);
        cols.push(color.r, color.g, color.b);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
    starField = new THREE.Points(geo, new THREE.PointsMaterial({ vertexColors: true, size: 1, transparent: true, opacity: 0.5 }));
    scene.add(starField);
}

function createParticleSystem() {
    particleGeometry = new THREE.BufferGeometry();
    const pos = new Float32Array(500 * 3);
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    particleSystem = new THREE.Points(particleGeometry, new THREE.PointsMaterial({ color: 0xffd700, size: 0.2 }));
    particleSystem.visible = false;
    scene.add(particleSystem);
}

function animate() {
    requestAnimationFrame(animate);
    if(starField) starField.rotation.y += 0.0003;
    rotationSpeed = THREE.MathUtils.lerp(rotationSpeed, targetSpeed, 0.05);
    if (!selectedCard && !isAnimating) cardGroup.rotation.y += rotationSpeed;
    renderer.render(scene, camera);
}

init();
window.addEventListener('resize', () => { 
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
});
</script> 
</body> 
</html>
