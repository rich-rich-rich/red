<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <title>红色记忆 - 沉浸在线版</title>  
    <style>  
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Microsoft YaHei', serif; }  
        canvas { display: block; }  
        #ui-layer {  
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);  
            width: 90%; max-width: 800px; color: #fff; text-align: center;  
            pointer-events: none; opacity: 0; z-index: 100; transition: opacity 0.5s;
        }  
        .card-inner-box {  
            background: radial-gradient(circle at center, rgba(80, 0, 0, 0.85) 0%, rgba(10, 0, 0, 0.95) 100%);  
            padding: 40px; border-radius: 30px; border: 1px solid rgba(255, 200, 0, 0.4);  
            box-shadow: 0 0 100px rgba(0,0,0,0.9); backdrop-filter: blur(15px);  
        }  
        .card-title { font-size: 3em; color: #f3e5ab; margin-bottom: 15px; letter-spacing: 10px; font-weight: bold; }  
        .card-sub { font-size: 1.4em; color: #ffcc00; margin-bottom: 20px; }
        .card-desc { font-size: 1.2em; line-height: 1.8; color: #eee; border-top: 1px solid rgba(255,215,0,0.3); padding-top: 20px; }  
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #ffcc00; }  
        #debug-info { position: fixed; bottom: 10px; left: 10px; color: rgba(255,255,255,0.3); font-size: 12px; z-index: 1001; }
    </style>  
</head>  
<body>  

<div id="loading-screen">  
    <div style="letter-spacing: 4px; font-size: 1.5em;">正在通过云端初始化记忆引擎...</div>  
</div>  

<div id="debug-info">请求摄像头权限中...</div>

<div id="ui-layer">  
    <div class="card-inner-box">  
        <div id="title" class="card-title"></div>  
        <div id="sub" class="card-sub"></div>
        <div id="desc" class="card-desc"></div>  
    </div> 
</div>  

<video id="video-input" style="display:none;" playsinline></video>  

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>  
let scene, camera, renderer, cardGroup, cards = [];
let lightPoint, particleSystem, particleGeometry, starField;
let raycaster = new THREE.Raycaster();
let isGrabbing = false, selectedCard = null, isAnimating = false;
let grabCounter = 0;
let rotationSpeed = 0.003, targetSpeed = 0.003;

const rawData = [
    { name: "湘江战役", sub: "雄关漫道真如铁，而今迈步从头越——《忆秦娥·娄山关》", desc: "湘江血雨虽寒，然星火不灭。后辈若逢困厄，当学此役之后，反思前路，校准方向，莫惧道阻且长。就算遇到像湘江战役这样的低谷和困难，反思后重新出发，直面挑战。" },
    { name: "遵义会议", sub: "“东方欲晓，莫道君行早”——《清平乐·会昌》", desc: "遵义城头，风雨虽急，然灯塔已明，后辈若迷方向，当循此智，而后明辨是非，笃定前行，莫失航标之光。遵义会议就像长征路上的“东方欲晓”，为红军指明了方向。" },
    { name: "四渡赤水", sub: "“你打你的，我打我的”——《毛泽东选集》", desc: "四渡赤水时，敌人在后面追，我们忽东忽西，不跟着敌人的节奏走，“以不变应万变”才走出了活路，别被外界的声音打乱脚步，坚持自己的节奏。" },
    { name: "巧渡金沙江", sub: "“兵无常势，水无常形”——《孙子兵法》", desc: "当年金沙江水流湍急，我们没有硬拼，靠的就是“变”的法子。遇到事情别死脑筋，换个角度想办法，路就活了。" },
    { name: "强渡大渡河", sub: "“为有牺牲多壮志，敢教日月换新天”——《七律·到韶山》", desc: "当年大渡河上，战友们用身体堵着漏洞。这“牺牲”不是要你们去拼命，谨记把这份“换新天”的劲儿，用在让日子更像样上。" },
    { name: "飞夺泸定桥", sub: "“狭路相逢勇者胜”——《毛泽东选集》", desc: "泸定桥的铁索晃得人心慌，不是蛮干，是明知危险也敢迈出的那一步。生活里总有需要“夺桥”的时刻，别被吓住，稳住脚、往前闯。" },
    { name: "翻雪山", sub: "“世上无难事，只要肯攀登”——《水调歌头·重上井冈山》", desc: "翻雪山时，谁也没丢下谁。遇到难处别自己硬扛，像我们当年那样，和身边人搭把手，攒着劲儿翻过眼前的雪山。" },
    { name: "过草地", sub: "“行到水穷处，坐看云起时”——《终南别业》", desc: "当年过草地，粮草断绝、泥水没膝。若遇困境，也别慌，停下来喘口气，看看身边的希望，等待新转机。" },
    { name: "吴起镇会师", sub: "“数风流人物，还看今朝”——《沁园春·雪》", desc: "我们终于摆脱了追兵，革命的火种总算保住了。你们要载着这份希望，带着我们的期盼，一直走下去。" },
    { name: "会宁会师", sub: "“云程发轫，万里可期”——《满江红·和郭沫若同志》", desc: "会宁会师时，我们摸着打补丁的军装笑，想着以后百姓能有暖衣穿。认真过好每一天，照顾好身边人，就是我们当年盼的未来。" },
    { name: "1949年中华人民共和国成立", sub: "人间正道是沧桑——《七律·人民解放军占领南京》", desc: "1949年开启复兴新程。沧桑这二字，藏着所有不容易，也藏着走到底的底气。愿你们沿着这沧桑正道一直走下去。" },
    { name: "十一届三中全会", sub: "“沉舟侧畔千帆过，病树前头万木春”——《酬乐天扬州初逢席上见赠》", desc: "就像遵义会议一样，找准了改革的新方向。迷茫时想想这两次转折，只要敢纠正，旧的迷雾即将散去。" },
    { name: "深圳等经济特区设立", sub: "“删繁就简三秋树，领异标新二月花”——《题画竹》", desc: "用“领异标新”的胆子去闯。遇到死局别硬扛，敢想新招、敢走新路，才有奔头。" },
    { name: "香港回归", sub: "“运筹帷幄之中，决胜千里之外”——《史记·高祖本纪》", desc: "香港回归是提前周密规划、掌控全局的成果。提前准备，胸有成竹，稳稳当当做成。" },
    { name: "澳门回归", sub: "自信人生二百年，会当水击三千里——《七古·残句》", desc: "心里像烧着一团火，知道这一仗没白打，再难的关也闯过来了。要坚信光明总有一天会来。" },
    { name: "加入国际世贸组织", sub: "“敢为天下先”——《道德经》", desc: "敢在未知中打开一扇门。面对新机会，别总想着等别人先走，看准了就去试，闯过去了，就是新天地。" },
    { name: "青藏铁路", sub: "“众人拾柴火焰高”", desc: "在冻土上打桩难，但大家抱成团。再难的事，一群人抱成团就没有办不成的。" },
    { name: "奥运会", sub: "“人心齐，泰山移”", desc: "个人的力量再强，也离不开身边人的托举。不管是当年过草地还是拼奥运，靠的都是信念。" },
    { name: "共产党成立100周年", sub: "星火已燎原，百年基业固", desc: "如今那真是像看到篝火燎原成了漫天星火！这盛世，比我们当年在篝火边聊的所有憧憬都要耀眼。" },
    { name: "长征胜利90周年", sub: "长征九秩开新境，马年盛世入画屏", desc: "这“新境”里，有你们桌上的热饭，窗外的高楼。你们好好守着这“新境”，就是我们最盼的事。" }
];

const tarotData = [...rawData];

function loadTex(name) {
    const loader = new THREE.TextureLoader();
    // 依然保留本地/相对路径加载，适配 GitHub Pages 目录下的图片
    const tex = loader.load('./' + encodeURIComponent(name) + '.jpg');
    tex.colorSpace = THREE.SRGBColorSpace; 
    return tex;
}

async function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 0); 

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputColorSpace = THREE.SRGBColorSpace; 
    document.body.appendChild(renderer.domElement);

    createGalaxy();
    createParticleSystem();
    createTarotRing();

    lightPoint = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 32, 32), 
        new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8 }) 
    );
    scene.add(lightPoint);
    scene.add(new THREE.AmbientLight(0xffffff, 2.4));

    await initHandTracking();
    
    gsap.to('#loading-screen', { opacity: 0, duration: 1.5, onComplete: () => {
        document.getElementById('loading-screen').style.display = 'none';
    }});
    animate();
}

function createTarotRing() {
    cardGroup = new THREE.Group();
    scene.add(cardGroup);
    const radius = 28; 
    const cardGeo = new THREE.BoxGeometry(5, 7.5, 0.1);
    const backTex = loadTex('back');

    tarotData.forEach((data, i) => {
        const angle = (i / tarotData.length) * Math.PI * 2;
        const mats = [
            new THREE.MeshStandardMaterial({ color: 0x222222 }), 
            new THREE.MeshStandardMaterial({ color: 0x222222 }),
            new THREE.MeshStandardMaterial({ color: 0x222222 }),
            new THREE.MeshStandardMaterial({ color: 0x222222 }),
            new THREE.MeshStandardMaterial({ map: loadTex(data.name) }), 
            new THREE.MeshStandardMaterial({ map: backTex })           
        ];
        const card = new THREE.Mesh(cardGeo, mats);
        card.position.set(Math.sin(angle) * radius, 0, Math.cos(angle) * radius);
        card.lookAt(0, 0, 0); 
        card.rotateY(Math.PI); 
        
        card.userData = { angle: angle, info: data, originPos: card.position.clone() };
        cards.push(card);
        cardGroup.add(card);
    });
}

function tryGrab() {
    if (selectedCard || isAnimating) return;
    const dir = lightPoint.position.clone().normalize();
    raycaster.set(new THREE.Vector3(0,0,0), dir);
    const intersects = raycaster.intersectObjects(cards);

    if (intersects.length > 0) {
        isAnimating = true;
        selectedCard = intersects[0].object;
        scene.attach(selectedCard);

        document.getElementById('title').innerText = selectedCard.userData.info.name;
        document.getElementById('sub').innerText = selectedCard.userData.info.sub;
        document.getElementById('desc').innerText = selectedCard.userData.info.desc;

        const tl = gsap.timeline({ onComplete: () => { isAnimating = false; } });
        tl.to(selectedCard.position, { x: 0, y: 0.5, z: -10, duration: 1.2, ease: "expo.out" }, 0)
          .to(selectedCard.rotation, { x: 0, y: 0, z: 0, duration: 1.2, ease: "expo.out" }, 0)
          .to('#ui-layer', { opacity: 1, duration: 0.8 }, 0.5);
    }
}

function tryRelease() {
    if (!selectedCard || isAnimating) return;
    isAnimating = true;
    gsap.to('#ui-layer', { opacity: 0, duration: 0.3 });

    const posAttr = particleGeometry.attributes.position;
    const velocities = [];
    for (let i = 0; i < 800; i++) {
        posAttr.array[i*3] = selectedCard.position.x; 
        posAttr.array[i*3+1] = selectedCard.position.y; 
        posAttr.array[i*3+2] = selectedCard.position.z;
        velocities.push((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2);
    }
    particleGeometry.userData.velocities = velocities;
    posAttr.needsUpdate = true;
    particleSystem.visible = true;

    const tempCard = selectedCard;
    const originAngle = tempCard.userData.angle;
    selectedCard = null;

    gsap.to(tempCard.scale, { x: 0, y: 0, z: 0, duration: 0.6, ease: "power2.in", onComplete: () => {
        cardGroup.attach(tempCard);
        tempCard.position.set(Math.sin(originAngle)*28, 0, Math.cos(originAngle)*28);
        tempCard.lookAt(0,0,0);
        tempCard.rotateY(Math.PI);
        gsap.to(tempCard.scale, { x:1, y:1, z:1, duration: 1.2, ease: "elastic.out(1, 0.5)" });
        isAnimating = false;
        setTimeout(() => { particleSystem.visible = false; }, 1000);
    }});
}

function createGalaxy() {
    const geo = new THREE.BufferGeometry();
    const pts = [], cols = [];
    for(let i=0; i<20000; i++) {
        const r = 400 + Math.random() * 600;
        const t = Math.random() * Math.PI * 2, p = Math.random() * Math.PI;
        pts.push(r * Math.sin(p) * Math.cos(t), r * Math.sin(p) * Math.sin(t), r * Math.cos(p));
        const rand = Math.random();
        const color = rand > 0.6 ? new THREE.Color(0xff4500) : (rand > 0.3 ? new THREE.Color(0xffd700) : new THREE.Color(0xff8c00));
        cols.push(color.r, color.g, color.b);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
    starField = new THREE.Points(geo, new THREE.PointsMaterial({ vertexColors: true, size: 0.8, transparent: true, opacity: 0.8 }));
    scene.add(starField);
}

function createParticleSystem() {
    particleGeometry = new THREE.BufferGeometry();
    const pos = new Float32Array(800 * 3);
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    particleSystem = new THREE.Points(particleGeometry, new THREE.PointsMaterial({ color: 0xffd700, size: 0.1, transparent: true }));
    particleSystem.visible = false;
    scene.add(particleSystem);
}

async function initHandTracking() {
    const debug = document.getElementById('debug-info');
    // 修改：使用 CDN 的二进制资源
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    
    hands.setOptions({ 
        maxNumHands: 1, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.7, 
        minTrackingConfidence: 0.7 
    });

    hands.onResults(res => {
        if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
            debug.innerText = "手势状态：已追踪";
            const p = res.multiHandLandmarks[0];
            const x = (0.5 - p[8].x) * 45; 
            const y = (0.5 - p[8].y) * 35;
            targetSpeed = (0.5 - p[8].x) * 0.1;
            lightPoint.position.lerp(new THREE.Vector3(x, y, -25), 0.15);

            const d = Math.hypot(p[4].x - p[8].x, p[4].y - p[8].y);
            if (d < 0.05) {
                grabCounter++;
                if (grabCounter > 5 && !isGrabbing) { tryGrab(); isGrabbing = true; }
            } else if (d > 0.1) {
                grabCounter = 0;
                if (isGrabbing) { tryRelease(); isGrabbing = false; }
            }
        } else {
            debug.innerText = "手势状态：未检测到手部";
        }
    });

    const video = document.getElementById('video-input');
    const cam = new Camera(video, { 
        onFrame: async () => { await hands.send({ image: video }); }, 
        width: 640, height: 480 
    });
    cam.start();
}

function animate() {
    requestAnimationFrame(animate);
    starField.rotation.y += 0.0002;
    rotationSpeed = THREE.MathUtils.lerp(rotationSpeed, targetSpeed, 0.05);
    if (!selectedCard && !isAnimating) cardGroup.rotation.y += rotationSpeed;
    
    if(particleSystem.visible && particleGeometry.userData.velocities) {
        const arr = particleGeometry.attributes.position.array;
        const v = particleGeometry.userData.velocities;
        for(let i=0; i<800; i++) {
            arr[i*3] += v[i*3];
            arr[i*3+1] += v[i*3+1];
            arr[i*3+2] += v[i*3+2];
        }
        particleGeometry.attributes.position.needsUpdate = true;
    }
    renderer.render(scene, camera);
}

init();
window.addEventListener('resize', () => { 
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
});
</script> 
</body> 
</html>
